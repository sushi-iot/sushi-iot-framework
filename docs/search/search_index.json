{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sushi IoT Framework","text":"<p>Sushi IoT is a firmware framework for boards based on ESP32 SoC, providing an environment that integrates solid system management with MicroPython.</p> <p>It is useful for students and makers to accelerate projects by using reliable building blocks to manage core functions, allowing you to focus on application development without getting lost in low-level system details.</p>"},{"location":"#overview","title":"Overview","text":""},{"location":"#features","title":"Features","text":"<p>Works on very common commercial boards based on ESP32 SoC, widely available online for DIY electronics projects.</p> <p>It simplifies development:  </p> <ul> <li>Hardware management: Wi-Fi, LCD, keyboard, modem, I/O expansion, relays, power detection, battery level, buzzer.</li> <li>Software features: System management via web UI (network and system settings, logs, status, etc.) and a physical interface for on-device menus.</li> <li>Embedded MicroPython environment: Users can run their own scripts freely, while built-in libraries provide optional system management features.</li> <li>Embedded high-level MicroPython libraries for rapid access to hardware and software functions (custom menus, web pages, I/O expansion, SMS, HTTP requests, etc.).</li> </ul> <p>Manages all essential components typically present in an IoT system, regardless of the specific application:</p> <ul> <li>Physical interface management (keyboard, display, status LEDs)</li> <li>Wireless connection as client or access point</li> <li>Drivers for all hardware components present on the board (I/O expander, modem, etc.)</li> <li>Web interface with user-level access (web server and UI)</li> <li>Modular menu management for physical interface</li> <li>High-level API for many typical functions: HTTP requests, SMS, GSM calls, web server extension, I2C communication, etc.</li> </ul>"},{"location":"#other-resources","title":"Other Resources","text":"<ul> <li>Sushi-IoT project on Kickstarter</li> <li>Sushi-IoT on Instagram</li> <li>Sushi-IoT-Board documentation</li> <li>Espressif ESP32-DevKitC V4 user guide</li> <li>MicroPython for ESP32</li> </ul>"},{"location":"#code-demo","title":"Code Demo","text":"<p>Manage relays via a custom menu</p> <p>Custom menu integration</p> <p> </p>"},{"location":"#applications","title":"Applications","text":"<ul> <li>Student experiments</li> <li>Home automation systems</li> <li>IoT central units</li> <li>Alarm systems</li> <li>Domotics servers</li> <li>Remote monitoring and data sampling systems (e.g., weather stations)</li> <li>Local and remote device control (via local interface, web interface, or modem)</li> </ul>"},{"location":"#workflow","title":"Workflow","text":"<p>Typical Sushi IoT Framework Project Workflow</p> Step #1Prepare your board Step #2Start and set up Step #3Start coding Step #4Benefit from the Sushi API"},{"location":"#credits","title":"Credits","text":"<p>This project embeds MicroPython, a lean and efficient implementation of Python 3 optimized for microcontrollers. We acknowledge and thank the MicroPython developers and contributors for their outstanding work. MicroPython is released under the MIT License.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>08/2025</p> <ul> <li>Base release that works for ESP32DevKitC with WROVER chip (and Sushi Board based on this module)</li> <li>Base documentation</li> </ul> <p>From 09/2025</p> <ul> <li>Extend MicroPython libraries with step-by-step software examples and projects\u2014not just basic tasks like blinking an LED, but full-scale DIY electronics systems based on the same core.</li> <li>Support for other ESP32 SoCs and boards</li> </ul>"},{"location":"coding/","title":"Sushi-IoT-Framework MicroPython interface","text":""},{"location":"coding/#micropython-introduction","title":"MicroPython introduction","text":"<p>Sushi-IoT-Framework embeds the great MicroPython project, so you can basically rely on all the MicroPython modules included and available online. That's a lot of stuff. Here we focus on the most important base concepts and highlight the differences between using standard MicroPython alone or inside Sushi-IoT-Framework. </p>"},{"location":"coding/#for-beginners","title":"For beginners","text":"<p>If you are new to MicroPython development, the advice is follow these steps:</p> <ol> <li>Connect your board with USB cable</li> <li>Choose a user interface for MicroPython scripting</li> <li>Browse the examples section where you can start play with some scripts ready to test and modify.</li> </ol> <p>Resources:</p> <ul> <li>ESP32 MicroPython quick reference, which gives a brief overview of the most common modules on the ESP32 microcontroller.  </li> <li>Sushi-IoT-Framework MicroPython interface</li> </ul>"},{"location":"coding/#connect-to-the-board","title":"Connect to the board","text":"<p>The first step to start coding is to connect to the MicroPython REPL interface. There are basically two alternatives to program your scripts on the board:</p> <ul> <li> <p>Connect with USB cable directly to the micro board using the USB/UART REPL interface.   This is the most common, quick, and reliable solution to program your board. If you have a PC and no problems connecting by cable to the board, this is the best way.</p> </li> <li> <p>Connect via Web interface (WebREPL).   WebREPL is an alternative. From our tests, it works, but there are some issues and aspects to improve before recommending it as the best solution. Even in the MicroPython project, it is still considered experimental.   The first thing to consider is that every time the board is reset (quite common during script development), the network connection is lost, so you have to wait until it reconnects. </p> </li> </ul> <p>Big advantages of WebREPL are:</p> <ul> <li>You do not need a cable connection to the device  </li> <li>Once connected via a browser, you can code from any device, not only from a classic Windows, Linux, or Mac PC</li> </ul> <p>For these reasons, WebREPL will surely be the subject of future improvements.</p>"},{"location":"coding/#choose-a-user-interface","title":"Choose a user interface","text":"<p>This section is for those who have no experience with MicroPython </p> <p>Once the board is connected to your PC (or theoretically using WebREPL), there are several user interfaces you can use to develop your scripts. The REPL interface is an interpreter that executes MicroPython commands, so from this interface you can interact with the device. The MicroPython command set includes commands to save/read files on the device's internal memory, which is managed by a file system accessible from MicroPython.</p> <p>You could use REPL from any serial terminal that opens the COM port, but interacting at such a low level is not comfortable for development beyond simple tests.  </p> <p>For this reason, there are utilities that provide a higher-level interface, letting you quickly perform tasks such as:</p> <ul> <li>Save Python files to the device memory (usually <code>.py</code> files), including: <ul> <li>Your application script files  </li> <li>New classes or MicroPython components to add functionality to the device</li> </ul> </li> <li>Open and edit files directly on the device</li> <li>Run the <code>.py</code> scripts in the device</li> <li>Perform other actions, like restarting the device to test startup behavior after adding auto-run scripts</li> </ul> <p>Some common interfaces for MicroPython development include:</p> <ul> <li>Arduino Lab for MicroPython \u2013 Arduino solution for MicroPython development  </li> <li>Thonny \u2013 Simple interface, easy to use even for beginners  </li> <li>mpremote \u2013 Command-line tool developed for MicroPython. Great for advanced users who prefer working with their own editor and sending commands from the prompt (Windows) or bash (Linux). Also useful for running scripts directly on the device.</li> </ul> <p>It\u2019s up to you which interface to choose. In our examples/tests, we often used Thonny.</p>"},{"location":"coding/#auto-run-a-script","title":"Auto run a script","text":"<p>After you develop a script that performs some function, it is typical to want it to run automatically when the device starts. It is important to know that MicroPython automatically runs two scripts at every boot:</p> <ul> <li>boot.py: typically contains system and hardware initialization commands.  </li> <li>main.py: this is the main script executed to run your application. Here is where you put your code or run other \".py\" scripts you created.  </li> </ul> <p>These two scripts can be placed, like any other \".py\" file, into the file system using your favourite MicroPython UI interface.</p>"},{"location":"coding/#differences-vs-micropython","title":"Differences vs MicroPython","text":"<p>Sushi-IoT-Framework manages some system/hardware tasks that in certain cases can conflict with the MicroPython implementation. The following table highlights some points to consider during MicroPython scripting.  </p> <p>Even though in the current release of Sushi-IoT-Framework there are some limitations, the roadmap is to remove them in future updates, allowing everything to be managed either by MicroPython or by Sushi-IoT-Framework modules. This table refers to the latest available version of Sushi-IoT-Framework-MicroPython integration: Sushi-IoT-Framework version.</p> MicroPython module Status Remarks ADC Disabled. The MicroPython implementation is not compatible with the current Sushi-IoT-Framework ADC management (most recent ESP32 drivers). Activating the ADC module is priority one.  Wi-Fi Disabled Sushi-IoT-Framework manages Wi-Fi connections with all the most common options. Using MicroPython would cause a conflict."},{"location":"coding/#known-bugs","title":"Known bugs","text":"<p>During MicroPython testing some bugs arose. The plan is to update the embedded MicroPython implementation to remove them.</p> <p>MicroPython known bugs</p> MicroPython module Problem WebREPL WebREPL is working but it's an experimental feature. During testing, cases were experienced where it completely blocked the microcontroller (requiring a power cycle). time time.localtime() function returns the wrong year. Other fields are correct. <p>Report an issue to mo.iot.wiz@gmail.com</p>"},{"location":"coding/#sushi-micropython-interface","title":"Sushi Micropython interface","text":"<p>Sushi-IoT-Framework extend the base MicroPython interface with some modules that let perform quickly certain task.  Over the system tasks that Sushi-IoT-Framework integrates these MicroPython modules are another advantage that let speed up your development, simplying to the minimum the complexity to perform certain operation. For example with just some line of code you can do operations like:</p> <ul> <li>send / receive an SMS to perform an operation remotely like switch on/off a light</li> <li>integrate the user interface menu to let manage a control locally on the device interface</li> </ul> <p>The MicroPython modules embedded in Sushi-IoT-Framework are 2 types:</p> <ul> <li>Sushi core module. The core of Sushi-IoT-Framework MicroPython interface, this module is developed in background in C language and include all Sushi-IoT-Framework MicroPython extensions.</li> <li>Extension modules. These are classic \".py\" modules embedded into Sushi-IoT-Framework (called frozen modules) firmware and uses in background the Sushi core module to perform the most common operations in the simpler way possible.  This is because sometimes use directly the Sushi MicroPython module can be a little more tricky.</li> </ul>"},{"location":"coding/#core-module","title":"CORE MODULE","text":"<p>This module is the core of Sushi-IoT-Framework MicroPython interface, is developed in background in C language and include all Sushi-IoT-Framework MicroPython extensions.</p> <pre><code>import sushi\nsushi.help()    #Show quick reference\n</code></pre> <p>sushi module has one main function cmd:</p> <pre><code>sushi.cmd(command , params)\n</code></pre> <p>All sushi.cmd(\"command\",...) return a tuple: (<code>err</code>:int, <code>result</code>:var) <code>err</code> = 0   =&gt; OK, <code>result</code> contains the command-specific value <code>err</code> != 0  =&gt; ERROR, <code>result</code> contains the error message (str)  </p>"},{"location":"coding/#system","title":"SYSTEM","text":"<ul> <li><code>sushi.cmd(\"ver\")</code> -&gt; str   Show the firmware version of the board  </li> <li><code>sushi.cmd(\"restart\" [, delay_ms:int=2000])</code> -&gt; none   Restart the board after the optional delay in milliseconds  </li> <li><code>sushi.cmd(\"set_log\", level:int [0=disable,1=enable,255=extended])</code> -&gt; none   Enable or disable REPL logging  </li> <li><code>sushi.cmd(\"register\", code:str)</code> -&gt; none   Register the device with a unique 64-character code  </li> <li><code>sushi.cmd(\"factory_reset\")</code> -&gt; none   Restore factory default settings  </li> </ul>"},{"location":"coding/#modem","title":"MODEM","text":"<ul> <li> <p><code>sushi.cmd(\"set_modem_hnd\", callback:func)</code> -&gt; none   Set a callback to handle modem events. <code>callback</code> args (a:tuple):     a[0] = event type [0=SMS received, 1=Incoming call, 2=SMS TX result]     a[1..] = event-specific data  </p> <ul> <li>if a[0] = 0 \u2192 (call_number:str, sms_text:str, time:str)  </li> <li>if a[0] = 1 \u2192 (call_number:str)  </li> <li>if a[0] = 2 \u2192 (id:int, tx_result:int [1=OK, 0=ERROR])  </li> </ul> </li> <li> <p><code>sushi.cmd(\"send_sms\", (text:str, number:str))</code> -&gt; int   Send an SMS message; returns the SMS ID if command accepted  </p> </li> </ul>"},{"location":"coding/#power","title":"POWER","text":"<ul> <li><code>sushi.cmd(\"read_power_state\")</code> -&gt; int [1=ON, 0=OFF]   Get the main power state  </li> <li><code>sushi.cmd(\"read_power_voltage\")</code> -&gt; float (V)   Read the main power voltage  </li> <li><code>sushi.cmd(\"read_batt_level\")</code> -&gt; float (%)   Get the battery level in percent  </li> <li><code>sushi.cmd(\"read_batt_voltage\")</code> -&gt; float (V)   Read the battery voltage  </li> </ul>"},{"location":"coding/#menu","title":"MENU","text":"<p>! before use this interface see frozen module <code>sushi_menu</code></p> <ul> <li><code>sushi.cmd(\"new_menu\", title:str)</code> -&gt; int (menu_id)   Create a new menu with the given title  </li> <li><code>sushi.cmd(\"new_menu_item_string\", (desc:str, print_cb:func))</code> -&gt; int (entry_id)   Create a new string menu item with a callback for printing  </li> <li><code>sushi.cmd(\"new_menu_item_edit_list\", (desc:str, changed_cb:func, init_index:int, val1:str, val2:str, ...))</code> -&gt; int (entry_id)   Create a new editable list menu item with initial value and change callback  </li> <li><code>sushi.cmd(\"add_entry_to_menu\", (menu_id:int, entry_id:int))</code> -&gt; none   Add an entry to the specified menu  </li> </ul>"},{"location":"coding/#gpio-sensors","title":"GPIO &amp; SENSORS","text":"<ul> <li><code>sushi.cmd(\"read_temperature\", sensor:int [0=DS18B20-1,1=DS18B20-2])</code> -&gt; float (\u00b0C)   Read temperature from the selected sensor  </li> <li><code>sushi.cmd(\"read_gpin\", source:int [0=IO-Expander])</code> -&gt; int (status)   Read digital input from the specified source  </li> <li><code>sushi.cmd(\"set_gpin_int\", callback:func)</code> -&gt; none   Set a callback to detect changes in input state   args (a:tuple) <code>callback</code> args (source:int [0 = IO-Expander])  </li> </ul>"},{"location":"coding/#frozen-modules","title":"FROZEN MODULES","text":""},{"location":"coding/#sushi_menu-module","title":"sushi_menu module","text":"<p>Simplified user menu management: this module expose a class that can be used to integrate custom menu into the system.  </p> <p>Usage:  </p> <pre><code>import sushi_menu\nsushi_menu.help()\n</code></pre> <pre><code>from sushi_menu import Submenu\n# Add a menu to the on-device interface\nmymenu = Submenu('Test Menu')\n\n# Add an entry to the menu\nmymenu.add_read_only_item(\"Test entry\" , ...)\n</code></pre> <ul> <li>Module Source code and DOC</li> <li>Full example</li> </ul>"},{"location":"coding/#examples","title":"Examples","text":""},{"location":"coding/#see-here-all-sushi-micropython-examples","title":"See here all Sushi MicroPython examples","text":""},{"location":"download/","title":"Download","text":""},{"location":"download/#sushi-iot-framework-firmware-releases","title":"Sushi-IoT-Framework firmware releases","text":""},{"location":"getting_started/","title":"Getting started to Sushi IoT Framework","text":""},{"location":"getting_started/#1-get-the-firmware","title":"1. Get the firmware","text":"<p>In the Sushi-IoT-Framework download page there is a table with all the releases for the supported boards. To get the latest features and fixes, it's recommended to use the latest stable version available.  </p>"},{"location":"getting_started/#2-flash-the-firmware","title":"2. Flash the firmware","text":"<p>Flashing the firmware can vary depending on the specific board you are using (in that case please check the producer documentation for more details).  </p> <p>We document here 2 options to flash the firmware that can fit on ESP32DevKitC-V4 and most ESP32 boards.  </p>"},{"location":"getting_started/#21-flash-by-online-tool","title":"2.1. Flash by ONLINE tool","text":"<p>Espressif provides an online tool that, using modern browser functions, can connect to your board via USB/COM port. The online tool is probably the easiest way to flash the firmware, but it's a \"young\" feature and depending on your system/browser/chip version may not work. If you have troubles, do not waste too much time on it; switch to the OFFLINE procedure, which is more reliable across all conditions.</p>"},{"location":"getting_started/#steps","title":"Steps","text":"<ol> <li>Plug your ESP32 board via USB into your PC.  </li> <li>Open the ESP Flash Tool in the browser.  </li> <li>Select 115200 as baud rate. Higher baud rates can cause issues; if you experience problems like \"Error: No serial data received\", switch to 115200.  </li> <li>Click \"Connect\" in the \"Program\" section and select the ESP32 board COM port. In the console, you should see the chip model and other info if the device is properly connected.  </li> <li>Start the board in boot mode (only if the program interface does not appear automatically).   <p>On the board: press the boot button, hold it, then press and release the reset button. If the step is successful, the web interface should display \"Connected to device:\" with all the buttons to program the board.</p> </li> <li>Press \"Erase Flash\" (recommended, especially for the first firmware load).  </li> <li>Select the firmware file (use the button on the right, not \"Add\"), set the Flash address to \"0\", and press \"Program\".</li> </ol>"},{"location":"getting_started/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If \"Error: No serial data received\" appears, use the lowest baud rate (115200).  </li> <li>If you see \"flash corruption\" in REPL after firmware download, reinstall the firmware using \"Erase Flash\".  </li> <li>If the chip is detected but Erase/Program fails, it is probably not in BOOT mode. Boot mode is automatic if the chip is blank/new; otherwise, follow step 5 carefully to reset the device into boot mode.  </li> </ul> <p>Tip: For every retry, refresh the tool page to start clean, and possibly unplug/replug the device.</p>"},{"location":"getting_started/#22-flash-by-offline-tool","title":"2.2. Flash by OFFLINE tool","text":"<p>Download the official Espressif tool for your system: ESPTOOL. For example, here you can get the .exe version of the tool. This is an easier alternative compared to the Python \".py\" version of the tool, which you can find here. If you use \"esptool.py\" replace \"esptool\" with \"esptool.py\" in all the following commands.</p>"},{"location":"getting_started/#erase-the-chip","title":"Erase the chip","text":"<p>This is required especially when you are flashing the firmware for the first time.</p> <pre><code>esptool erase_flash\n</code></pre>"},{"location":"getting_started/#flash-the-firmware-file","title":"Flash the firmware file","text":"<p><code>esptool write_flash 0x0 FIRMWARE.bin</code></p> <p>Where \"FIRMWARE\" is the firmware .bin file that you downloaded. See Sushi-IoT-Framework firmware download.</p>"},{"location":"getting_started/#troubleshooting_1","title":"Troubleshooting","text":"<ul> <li>esptool fails to detect the correct COM port: specify it with the \"--port\" option in front of the command.</li> </ul> <pre><code>esptool --port PORTNAME ...\n</code></pre> <p>Where PORTNAME: - On Linux, usually something like <code>/dev/ttyUSB</code>. - On Mac, usually something like <code>/dev/cu.usbmodem01</code>. - On Windows, usually something like <code>COM5</code>.  </p> <p>If these steps don't work, consult the esptool documentation from Espressif:</p> <ul> <li>esptool basic options </li> <li>esptool documentation</li> </ul>"},{"location":"getting_started/#23-test-the-firmware","title":"2.3. Test the firmware","text":"<p>After successfully loading the firmware, you can quickly check that everything is working by connecting to the MicroPython REPL.</p> <p>You have two options:</p> <ul> <li>Serial tool: connect with any serial terminal to the USB port.   See the coding section of the manual for details.</li> <li>Web tool: use the online COM monitor provided by Espressif on the same page as the ESP Flash Tool.</li> </ul> <p>Steps for the web tool:</p> <ol> <li>If you previously used it to flash the firmware, refresh the page.  </li> <li>In the Console section, set the baud rate to 115200, click Start, and select the COM port of your board.  </li> <li>On the device, press the RESET button.</li> </ol> <p>If everything works, you should see the device boot and the MicroPython REPL:</p> <pre><code>...\nMicroPython 495ce91-dirty on ... Sushi firmware framework on ... with ESP32\nType \"help()\" for more information.\n&gt;&gt;&gt; \n</code></pre>"},{"location":"getting_started/#3-setup-and-wi-fi-connection","title":"3. Setup and Wi-Fi connection","text":"<p>When the firmware is freshly flashed, the board starts Wi-Fi in access point mode. By scanning available networks, you should see an SSID like \"Sushi-...\" (the suffix is the device MAC address).</p> <p>You can connect your PC or smartphone to this Wi-Fi network and open the web interface at: <code>http://192.168.1.100</code> </p> <p>\u26a0\ufe0f Use http://, not https:// \u2014 HTTPS is supported but not enabled by default.</p> <p>Default network settings:</p> <ul> <li>SSID: \"Sushi-...\"  </li> <li>Password: (empty) </li> <li>IP address: \"192.168.1.100\"  </li> <li>User: \"root\"  </li> <li>Password: \"1976\"  </li> </ul> <p>From the web interface, you can adjust the base system settings and OPTIONALLY configure the device to connect to your Wi-Fi network. For more details about the Sushi-IoT-Framework web interface, see the system setup section.</p>"},{"location":"getting_started/#4-start-coding","title":"4. Start coding","text":"<p>Once the device is configured, you can start coding with your preferred MicroPython interface. In this guide, the examples use Thonny, but several alternatives are available.  </p> <p>For more details, see the coding section.</p>"},{"location":"manual/","title":"Sushi-IoT-Framework Software Manual","text":"<p>This guide refers to the Sushi-IoT-Framework latest firmware versions.</p>"},{"location":"manual/#coding","title":"Coding","text":"<p>Sushi-IoT-Framework embeds the MicroPython REPL interface, for coding refer to the Sushi-IoT-Framework coding.</p>"},{"location":"manual/#integrated-tasks-components","title":"Integrated tasks &amp; components","text":"<p>Sushi-IoT-Framework integrates some common system tasks and software components that can be useful to speed up development.</p> Task name Description Requirements Wi-Fi Wi-Fi network connection management ESP32 chip only Web interface Web user interface accessible by a browser ESP32 chip only Setup System setup via configuration file ESP32 chip only Log &amp; Events System log and event register management ESP32 chip only System health Monitor system status.Log traces, store to file, and send device status remotely.Manage status LEDs - (OPTIONAL) External LEDs - (OPTIONAL) Voltage divider for ADC inputs to read battery level and power status On-device interface On-device user interface with screen and keypad - 4-button keypad - OLED screen Modem Modem management to enable high-level functions like sending/receiving SMS, performing HTTP GET/POST Modem module Temperature Manage temperature sensors Temperature sensor Data manager Manage and send data remotely via HTTP POST, switching automatically between Wi-Fi and modem - (OPTIONAL) Modem"},{"location":"manual/#hardware-compatibility","title":"Hardware compatibility","text":"<p>Some of the tasks integrated into Sushi-IoT-Framework manage external hardware. So the questions are:</p> <ul> <li>On which pin connect the external devices</li> <li>What's the exact models of the chip that are managed</li> </ul> <p>The base is always an ESP32 SoC then the exact pin mapping used to manage the externals peripherical depends on the specific board you're using. It's possible that in the future there will be a \"jolly\" version that will let define all by configuration file, by now to ensure a correct and tested association (not every pin can do every function) the link is defined by the board-specific firmware. So to understand where connect the external devices, refer to your board hardware manual.</p> <p>The Sushi-IoT-Framework project is born with Sushi-IoT-Board so basically refer to Sushi-IoT-Board hardware Manual to check what's the managed modules and which are the pins to be used. If you use a stand-alone ESP32DevKitC board start from the microcontroller schematic diagram (ESP32DevKitC board) to check where the external devices expect to be connected:  Sushi-IoT-Board micro.</p>"},{"location":"manual/#wi-fi-management","title":"Wi-fi management","text":"<p>The wi-fi management let setup the device to work in 2 ways:</p> <ul> <li>Act as wi-fi access point</li> <li>Connect to am existing wi-fi network</li> </ul> <p>The setup can be done by the web-interface.</p> <p>Default network settings</p> <ul> <li>Wi-fi mode: Access point</li> <li>Network SSID: \"Sushi-...\"</li> <li>Network password: \"\"</li> <li>IP address: 192.168.1.100</li> </ul> <p>Extra functions</p> <ul> <li>The system parameter powersave_time_wifi_off_min defines the timeout (in minutes).  If the device cannot connect to the configured Wi-Fi network (or, in AP mode, no client is connected) for longer than this time, the wireless hardware is switched off to save energy. Reconnection can then be done either by restarting the device or using the on-device interface.</li> <li>It is always possible to force the Wi-Fi to run in access point mode by holding the designated button for about 15 seconds. This does not reset the device to factory settings: it only forces Wi-Fi to start in AP mode with default network settings (IP address <code>192.168.1.100</code> and no password). At the next reboot, the device will start according to the saved configuration. The specific button depends on the CPU board: <ul> <li>ESP32DevKitC board: use the onboard \"BOOT\" button.</li> </ul> </li> </ul>"},{"location":"manual/#web-interface","title":"Web interface","text":"<p>The web interface is divided into the following sections:</p> <ul> <li>HOME: customizable via the Sushi-IoT-Framework API, with links to application-specific pages  </li> <li>SETTINGS: contains all system settings  </li> <li>STATUS: displays system information  </li> </ul> <p>Access is protected by user levels with 3 profiles. HTTPS is supported (default is HTTP).  </p> <p>Default users</p> User name Grants Default password user Read-only access \"1234\" admin Read-write access with some limitations \"2801\" root Full read-write access including system updates \"1976\""},{"location":"manual/#system-setup","title":"System setup","text":"<p>The Sushi-IoT-Framework can be configured through the web interface. Basic settings are available as user controls directly in the interface, while all settings (basic + advanced) can be managed using a configuration file. The configuration file can be saved or loaded from the web UI using the controls at the bottom of the Settings section.  </p>"},{"location":"manual/#factory-restore","title":"Factory restore","text":"<ul> <li>If you lose Wi-Fi connection and just need to access the web UI, you can force AP mode by pressing the dedicated onboard button (see Wi-Fi extra functions).  </li> <li>A full factory restore can be performed by sending a command from the MicroPython REPL, see Sushi-IoT-Framework coding.  </li> </ul>"},{"location":"manual/#advanced-settings","title":"Advanced settings","text":"<ul> <li>The most important settings are available in the web interface; direct editing of the configuration file should be done carefully (e.g., when you need access to all parameters or to save/restore a full configuration).  </li> <li>All Wi-Fi parameters are already exposed in the web interface, so they are not listed in the configuration file.  </li> </ul>"},{"location":"manual/#system-parameters","title":"System parameters","text":"Parameter Description Values device_name Device name/description String data_file_version Configuration file version String ioex_enable Enable I/O expander management Integer0=none1=PCF8575 ext_temperature_sensor_enable Enable temperature sensor Integer0=none1=DS18B20 rele_out_enable Enable relay outputs Integer0=none1..2=number of relays keyboard_enable Enable keypad buttons (requires ioex_enable) Integer0=noneN=number of buttons ext_leds_enable Number of external status LEDs connected to GPIO Integer0=noneN=number of LEDs (mapped from GPIO0; max depends on board)LEDs are named \"EXT_LED_1\", \"EXT_LED_2\", \u2026 lcd_enable Enable display Integer0=none1=OLED_SSD1306 buzzer_enable Enable buzzer Integer0=none1=buzzer enabled battery_enable Battery level range Integer0=none1=reserved2=1 li-ion cell (1S) ~3.0\u20134.2V3=3 li-ion cells (3S) ~9\u201312.6V extension_modules Enable extra experimental modules StringReserved system_info_log_frequency_min System info log frequency (minutes) Integer0=neverN=minutes system_info_store_frequency_min System info storage frequency (minutes). Requires system_info_csv_filter. Integer0=neverN=minutes system_info_csv_filter Filter for system status entries stored when system_info_store_frequency_min \u2260 0 String<code>\"&lt;entry_info_1&gt;*&lt;entry_info_2&gt;*...\"</code> system_info_send_http_post_frequency_min HTTP POST system info frequency (minutes). Posts are sent to http_post_delivery_address. Integer0=neverN=minutes wifi_status_led Assign wi-fi status to an external LED String\"EXT_LED_1\", \"EXT_LED_2\", \u2026 system_status_led Assign system status to an external LED String\"EXT_LED_1\", \"EXT_LED_2\", \u2026 event_register_size_kb Event register file size Integer0=no event fileN=Max KB time_zone_hours Time zone offset from UTC Integer-12\u2026+14 time_auto_daylight_save_change Enable automatic daylight saving change (European rules) Integer0=disabled1=enabled powersave_time_wifi_off_min Auto wi-fi power-off after inactivity (minutes) Integer0=disabledN=minutes http_post_delivery_address Server address for HTTP POST. Custom application-specific data can be sent by the Sushi-IoT-Framework API StringExample: \"https://your_web_server/post_data.php\" ntp_server_address NTP server address StringDefault: \"pool.ntp.org\" use_wifi_for_http_post Use wi-fi before modem for HTTP POST Integer0=disabled1=enabled modem_enable Enable modem management Integer0=none1=SIMCOM7672X modem_sim_sms_center SIM SMS center number StringExample: \"+393519999600\" modem_sim_pin SIM PIN code StringExample: \"1234\" modem_apn SIM APN name StringExample: \"iliad\" modem_user APN user StringOptional modem_passwd APN password StringOptional"},{"location":"manual/#log-events","title":"Log &amp; Events","text":"<p>System log and events can be useful to monitor &amp; debug the system working.  Both can be accessed by the web-interface in the status page. Log can be enabled even from the MicroPython REPL interface.  Logs are cleared at every system restart while events are stored into a file. The max events file size is defined by the configuration parameter event_register_size_kb.</p>"},{"location":"manual/#system-health-monitor","title":"System health &amp; monitor","text":"<p>System health is a component useful to monitor the device status in different ways:</p> <ul> <li>Read the battery level and main power supply status. Require to connect battery and power to 2 ADC input with proper external resistor divider. For pinout details see Sushi-board or your board hardware manual. Configuration parameter: battery_enable</li> <li>Trace to log the system status (configuration parameter system_info_log_frequency_min).</li> <li>Store to file the system status (configuration parameters system_info_store_frequency_min and system_info_csv_filter).</li> <li>Send remotely the device status by http POST. Useful for example to monitor remotely an IoT device. This function requires setting the parameters system_info_send_http_post_frequency_min (frequency) and http_post_delivery_address (destination). </li> <li>Manage status LEDs. Let monitor the status by LEDs connected to the device. (configuration parameter ext_leds_enable) <ul> <li>System status: function enabled by system_status_led parameter. 1 slow blink indicates OK, otherwise it's an error state. </li> <li>Wi-Fi status: function enabled by wifi_status_led parameter. 1 slow blink indicates client connected; quick continuous blink indicates access point mode; otherwise it's an error state. </li> </ul> </li> </ul>"},{"location":"manual/#on-device-interface","title":"On-device interface","text":"<p>This component manages a system menu accessible by a screen and a keypad directly on the device. Basically the following submenus are present:</p> <ul> <li>Diagnostic: several diagnostic info about the device, like battery level, temperature, etc.</li> <li>System info: versions and date-time info.</li> <li>Wi-Fi: Wi-Fi connection status, IP, option to force Wi-Fi off or in access point mode.</li> <li>Modem: modem status and network info.</li> </ul> <p>Configuration parameters: keyboard_enable, lcd_enable, ioex_enable.</p> <p>The standard menu management uses a 4 buttons keyboard (keyboard_enable = 4) to navigate: NEXT, PREVIOUS, BACK, ENTER.</p> <p>The menu can be extended with application specific submenus by Sushi-IoT-Framework coding.</p>"},{"location":"manual/#modem-management","title":"Modem management","text":"<p>Modem management component:</p> <ul> <li>Perform the background tasks to manage the modem by AT commands, including SIM management (PIN, SMS center, APN, etc.). This includes a quite reliable monitor of the modem status, performing all the actions to keep the modem always available and working properly. To achieve maximum reliability, it is recommended to also connect the MOS-controlled modem power control.</li> <li>Enable the Sushi-IoT-Framework API to easily perform high-level functions like send/receive SMS, perform HTTP GET/POST, and trigger actions when calls from certain numbers are received. See Sushi-IoT-Framework coding.</li> </ul> <p>Anyone who worked on low-level modem management knows how tricky it can be to perform all the required tasks reliably. This component makes common operations quite easy.</p>"},{"location":"manual/#temperature-sensor","title":"Temperature sensor","text":"<p>This component simply manages one or more temperature sensors that can be read in different ways: in the system status, in the user menus, or via Sushi-IoT-Framework coding. Configuration parameter: ext_temperature_sensor_enable.</p>"},{"location":"manual/#data-manager","title":"Data manager","text":"<p>In an IoT application it is common to have data to send remotely to some server (e.g., sensor data or alarms). This component manages all the tasks:</p> <ul> <li>Send data by HTTP POST.</li> <li>Put the data into a queue to manage multiple requests simultaneously.</li> <li>Manage different retries in case of errors.</li> <li>Try Wi-Fi if available; if not, switch automatically to use the modem (which requires a completely different and tricky management).</li> <li>Finally, fire a callback to give feedback when the process ends.</li> </ul> <p>The Sushi-IoT-Framework API provides an interface to this component, simplifying the process with minimal effort. Configuration parameters: http_post_delivery_address, use_wifi_for_http_post.</p>"}]}